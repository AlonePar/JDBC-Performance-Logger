package slaurent.jdbcperflogger;

import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.ArrayList;
import java.util.List;
import java.util.UUID;

public class StatsLoggingStatement extends WrappingStatement implements Statement {
    protected final WrappingConnection wrappingConnection;
    private final List<String> batchedNonPreparedStmtExecutions = new ArrayList<String>();

    public StatsLoggingStatement(final Statement wrappedStatement, final WrappingConnection wrappingConnection) {
        super(wrappedStatement);
        this.wrappingConnection = wrappingConnection;
    }

    private <V> V executeAndLogPerf(final String sql, final SqlCallable<V> callable) throws SQLException {
        final long start = System.nanoTime();
        SQLException exc = null;
        try {
            return callable.call();
        } catch (final SQLException e) {
            exc = e;
            throw e;
        } finally {
            final long end = System.nanoTime();
            PerfLogger.logStatement(UUID.randomUUID(), sql, end - start, StatementType.BASE_NON_PREPARED_STMT, exc);
        }
    }

    @Override
    public ResultSet executeQuery(final String sql) throws SQLException {
        final UUID logId = UUID.randomUUID();
        final long start = System.nanoTime();
        SQLException exc = null;
        try {
            final ResultSet resultSet = super.executeQuery(sql);
            return new StatsLoggingResultSet(resultSet, logId, StatementType.NON_PREPARED_QUERY_STMT);
        } catch (final SQLException e) {
            exc = e;
            throw e;
        } finally {
            final long end = System.nanoTime();
            PerfLogger.logStatement(logId, sql, end - start, StatementType.NON_PREPARED_QUERY_STMT, exc);
        }

    }

    @Override
    public int executeUpdate(final String sql) throws SQLException {
        return executeAndLogPerf(sql, new SqlCallable<Integer>() {

            public Integer call() throws SQLException {
                return StatsLoggingStatement.super.executeUpdate(sql);
            }
        });
    }

    @Override
    public boolean execute(final String sql) throws SQLException {
        return executeAndLogPerf(sql, new SqlCallable<Boolean>() {

            public Boolean call() throws SQLException {
                return StatsLoggingStatement.super.execute(sql);
            }
        });
    }

    @Override
    public int executeUpdate(final String sql, final int autoGeneratedKeys) throws SQLException {
        return executeAndLogPerf(sql, new SqlCallable<Integer>() {

            public Integer call() throws SQLException {
                return StatsLoggingStatement.super.executeUpdate(sql, autoGeneratedKeys);
            }
        });
    }

    @Override
    public int executeUpdate(final String sql, final int[] columnIndexes) throws SQLException {
        return executeAndLogPerf(sql, new SqlCallable<Integer>() {

            public Integer call() throws SQLException {
                return StatsLoggingStatement.super.executeUpdate(sql, columnIndexes);
            }
        });
    }

    @Override
    public int executeUpdate(final String sql, final String[] columnNames) throws SQLException {
        return executeAndLogPerf(sql, new SqlCallable<Integer>() {

            public Integer call() throws SQLException {
                return StatsLoggingStatement.super.executeUpdate(sql, columnNames);
            }
        });
    }

    @Override
    public boolean execute(final String sql, final int autoGeneratedKeys) throws SQLException {
        return executeAndLogPerf(sql, new SqlCallable<Boolean>() {

            public Boolean call() throws SQLException {
                return StatsLoggingStatement.super.execute(sql, autoGeneratedKeys);
            }
        });
    }

    @Override
    public boolean execute(final String sql, final int[] columnIndexes) throws SQLException {
        return executeAndLogPerf(sql, new SqlCallable<Boolean>() {

            public Boolean call() throws SQLException {
                return StatsLoggingStatement.super.execute(sql, columnIndexes);
            }
        });
    }

    @Override
    public boolean execute(final String sql, final String[] columnNames) throws SQLException {
        return executeAndLogPerf(sql, new SqlCallable<Boolean>() {

            public Boolean call() throws SQLException {
                return StatsLoggingStatement.super.execute(sql, columnNames);
            }
        });
    }

    @Override
    public void addBatch(final String sql) throws SQLException {
        super.addBatch(sql);
        batchedNonPreparedStmtExecutions.add(sql);
    }

    @Override
    public void clearBatch() throws SQLException {
        super.clearBatch();
        batchedNonPreparedStmtExecutions.clear();
    }

    @Override
    public int[] executeBatch() throws SQLException {
        final long start = System.nanoTime();
        SQLException exc = null;
        try {
            return super.executeBatch_internal();
        } catch (final SQLException e) {
            exc = e;
            throw e;
        } finally {
            final long end = System.nanoTime();
            PerfLogger.logNonPreparedBatchedStatements(batchedNonPreparedStmtExecutions, end - start,
                    wrappingConnection.databaseType, exc);
            batchedNonPreparedStmtExecutions.clear();
        }

    }

    protected static interface SqlCallable<V> {
        V call() throws SQLException;
    }

}